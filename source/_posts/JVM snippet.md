---
title: jvm snippet
date: 2018-01-18 22:00:30
tags: snippet
categories: java
---

## JRE JVM JDK

- JRE:	java run-time

> Java is every where in browser, in mobile, in TV or in set-top boxes and if you are into Java programming language than you know that Java code which is bundled in JAR (Java archive) file require Java virtual machine JVM to execute it. 

- JVM:	java virtual machine

>  Java Virtual Machine is get created when you run a java program using java command e.g. java HelloWorld. JVM is responsible for converting byte code into machine specific code

- JDK:	java development kit

>  JDK is also loosely referred as JRE but its lot more than JRE and it provides all the tools and executable require to compile debug and execute Java Program.

## basic architecture of the JVM

![](https://i.imgur.com/yI8u4Hr.jpg)

### Class Loader Sub System

#### 1. Loading

- loading the class file and store inside method area

  ![](https://i.imgur.com/57IalMb.png)

- Created object is not student object or customer object. It is a predefined class “Class” object that is presently in java.lang package.

  ![](https://i.imgur.com/9hHykjw.png)

- For every loaded .class file, only one class "Class" object will be created by JVM, even though we are using that class multiple times in our program. Example,

  ![](https://i.imgur.com/KKpqYVn.png)

#### 2. Linking

- **verification** 

  > This Byte Code Verifier is responsible to verify weather .class file is properly formatted or not, structurally correct or not, generated by valid compiler or not.

- **preparation** 

  > allocate memory for class level static variables and assigned default values.
  >
  > E.g. For int ---> 0, For double ---> 0.0, For boolean ---> false

- **Resolution**

  > It is the process of replacing all symbolic references used in our class with original direct references from method area.

  ![](https://i.imgur.com/jTM8BJz.png)

- **Initialization**

> In Initialization activity, for class level static variables assigns original values and static blocks will be executed from top to bottom.

- Types of class loaders in class loader subsystem
  - Bootstrap class loader/ Primordial class loader
  - Extension class loader
  - Application class loader/System class loader

#### 3. Class loader sub system follows delegation hierarchy algorithm

![](https://4.bp.blogspot.com/-iMNVExYkMHU/VyMRlZEllzI/AAAAAAAAAZk/slOt-86cWUIR5bLdRRYo5d83O63-7iGqgCLcB/s640/JVM3.png)

- **Customized class loader**

  Sometimes we may not satisfy with default class loader mechanism then we can go for Customized class loader. For example:

  ![](https://2.bp.blogspot.com/-eaOaDxPhWh4/VyMvvGfOO9I/AAAAAAAAAZ4/3v1d3iuqieMWMp5_HfKiRLaChQFcmFIMACLcB/s640/JVM4.png)

### Various Memory Areas in JVM

#### 1. Method Area

- Inside method area class level binary data including static variables will be stored

- Constant pools of a class will be stored inside method area.

- Method area can be accessed by multiple threads simultaneously.

  > All threads share the same method area, so access to the method area's data structures must be designed to be thread-safe. 

  ![](https://2.bp.blogspot.com/-u01Q_6NhvPk/VyM_pBkp3kI/AAAAAAAAAag/MgiZfTRTz0wxG6-6SEB02hTM7_ZE3SMHQCKgB/s1600/Untitled.png)

#### 2. Heap Area

- Objects and corresponding instance variables will be stored in the heap area.
- Every array in java is object only hence arrays also will be stored in the heap area.

- Heap area can be access by multiple threads and hence the data stored in the heap area is not thread safe.

![](https://2.bp.blogspot.com/-oLUpq44AMXM/VyNIAVtyZ3I/AAAAAAAAAa0/lCVcaictQnk0MxCpCwxbUpXyL4Fy_83gACLcB/s1600/Untitled.png)

```
Set Maximum and Minimum heap size
-Xmx
     To set maximum heap size , i.e., maxMemory
    java -Xmx512m HeapSpaceDemo
     Here mx = maximum size
              512m = 512 MB
              HeapSpaceDemo = Java class name
-Xms
     To set minimum heap size , i.e., total memory 
        java -Xms65m HeapSpaceDemo   
      Here ms = minimum size
              65m = 65 MB
              HeapSpaceDemo = Java class name
or, you can set a minimum maximum heap size at a time
java -Xms256m -Xmx1024m HeapSpaceDemo
```

#### 3. Stack Memory

- Each and every method call performed by the thread and corresponding local variables will be stored by in the stack,

  ![](https://2.bp.blogspot.com/-K03M6Uni9m4/VyRNcS9tf4I/AAAAAAAAAbQ/MYBamJ20cb08iQTbDmnNmO4DyxMR_2giACLcB/s1600/Untitled.png)


##### Stack Frame Structure

- Local Variable Array

  - It contains all parameters and local variables of the method.

  - the occupied slot 

    ![](https://4.bp.blogspot.com/-ROv0VjQvVGs/VyRf_zpQSpI/AAAAAAAAAbk/4kX92SN32gwi5KW4tPgQlEYmcnADWqrwgCLcB/s1600/Untitled.png)

- Operand Stack

  - JVM uses operand stack as work space.

  - last-in first-out (LIFO) 

  - how a Java virtual machine would add two local variables that contain ints and store the int result in a third local variable:

    ![](https://3.bp.blogspot.com/-z0BIzBb7RSk/VyRoO5281LI/AAAAAAAAAb4/xU2X3082YSA7qyoelCxDj36l8luQkWjgwCLcB/s1600/Untitled.png)

- Frame Data

#### 4. PC Registers(Program Counter Registers)

> For every thread a separate PC register will be created at the time of thread creation. PC register contains address of current executing instruction. Once instruction execution completes automatically PC register will be incremented to hold address of next instruction. An "address" can be a native pointer or an offset from the beginning of a method's byte codes.   

#### 5. Native Method Stacks

> Here also for every Thread a separate run time stack will be created. It contains all the native methods used in the application. Native method means methods written in a language other than the Java programming language. In other words, it is a stack used to execute C/C++ codes invoked through JNI (Java Native Interface). According to the language, a C stack or C++ stack is created.

![](https://4.bp.blogspot.com/-4bE2RL52NtA/VyRuBlfum-I/AAAAAAAAAcM/LzCOXj-d1F81ipQsZWs17QohYqrolOo0gCLcB/s1600/Untitled.png)

![](https://1.bp.blogspot.com/-YIMpPCtloyM/VyRvvs1tf0I/AAAAAAAAAcY/XkvoL2nuRS8hKUDMHR3gw0OCjaUeePrzQCLcB/s1600/Untitled.png)

### Execution Engine

#### 1. Interpreter

> It is responsible to read byte code and interpret into machine code (native code) and execute that machine code line by line. 

#### 2. JIT Compiler

> The JIT compiler has been introduced to compensate for the disadvantages of the interpreter. The main purpose of JIT compiler is to improve the performance. Internally JIT compiler maintains a separate count for every method. Whenever JVM across any method call, first that method will be interpreted normally by the interpreter and JIT compiler increments the corresponding count variable. 

- **Profiler** which is the part of JIT compiler is responsible to identify Hotspot(Repeated Used Methods).

![](https://1.bp.blogspot.com/-ANGvCzUbah4/VyXPF7DZ_vI/AAAAAAAAAdw/WXoC1nvYlLcPgVxyyLfSQtD6wM2fCDzMwCLcB/s1600/Untitled.png)

### Java Native Interface(JNI)

> JNI is acts as a bridge (Mediator) for java method calls and corresponding native libraries. 

![](https://3.bp.blogspot.com/-0qA9I4nPJ5s/VyXRhVVabDI/AAAAAAAAAeE/JYW4byFQCMICubzScaBIaQvEVblinG7cgCLcB/s1600/Untitled.png)


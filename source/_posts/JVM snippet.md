---
title: jvm snippet
date: 2018-01-18 22:00:30
tags: snippet
categories: java
---

## JRE JVM JDK

- JRE:    java run-time

> Java is every where in browser, in mobile, in TV or in set-top boxes and if you are into Java programming language than you know that Java code which is bundled in JAR (Java archive) file require Java virtual machine JVM to execute it. 

- JVM:    java virtual machine

>  Java Virtual Machine is get created when you run a java program using java command e.g. java HelloWorld. JVM is responsible for converting byte code into machine specific code

- JDK:    java development kit

>  JDK is also loosely referred as JRE but its lot more than JRE and it provides all the tools and executable require to compile debug and execute Java Program.

## basic architecture of the JVM

<img src="https://i.imgur.com/yI8u4Hr.jpg" style="width:50%">

### Class Loader Sub System

#### 1. Loading

- loading the class file and store inside method area
  
  <img src="https://i.imgur.com/57IalMb.png" style="width:50%">

- Created object is not student object or customer object. It is a predefined class “Class” object that is presently in java.lang package.
  
  <img src="https://i.imgur.com/9hHykjw.png" style="width:70%">

- For every loaded .class file, only one class "Class" object will be created by JVM, even though we are using that class multiple times in our program. Example,
  
  <img src="https://i.imgur.com/KKpqYVn.png" style="width:70%">

#### 2. Linking

- **verification** 
  
  > This Byte Code Verifier is responsible to verify weather .class file is properly formatted or not, structurally correct or not, generated by valid compiler or not.

- **preparation** 
  
  > allocate memory for class level static variables and assigned default values.
  > 
  > E.g. For int ---> 0, For double ---> 0.0, For boolean ---> false

- **Resolution**
  
  > It is the process of replacing all symbolic references used in our class with original direct references from method area.
  
  ![](https://i.imgur.com/jTM8BJz.png)

- **Initialization**

> In Initialization activity, for class level static variables assigns original values and static blocks will be executed from top to bottom.

- Types of class loaders in class loader subsystem
  - Bootstrap class loader/ Primordial class loader
  - Extension class loader
  - Application class loader/System class loader

#### 3. Class loader sub system follows delegation hierarchy algorithm

- **Customized class loader**
  
  Sometimes we may not satisfy with default class loader mechanism then we can go for Customized class loader. For example:

### Various Memory Areas in JVM

#### 1. Method Area

- Inside method area class level binary data including static variables will be stored

- Constant pools of a class will be stored inside method area.

- Method area can be accessed by multiple threads simultaneously.
  
  > All threads share the same method area, so access to the method area's data structures must be designed to be thread-safe. 

#### 2. Heap Area

> **Heap space in Java is used for dynamic memory allocation for Java objects and JRE classes at the runtime**. New objects are always created in heap space and the references to this objects are stored in stack memory.

These objects have global access and can be accessed from anywhere in the application.

This memory model is further broken into smaller parts called generations, these are:

1. **Young Generation –** this is where all new objects are allocated and aged. A minor Garbage collection occurs when this fills up
2. **Old or Tenured Generation –** this is where long surviving objects are stored. When objects are stored in the Young Generation, a threshold for the object’s age is set and when that threshold is reached, the object is moved to the old generation
3. **Permanent Generation –** this consists of JVM metadata for the runtime classes and application methods
- It’s accessed via complex memory management techniques that include Young Generation, Old or Tenured Generation, and Permanent Generation
- If heap space is full, Java throws *java.lang.OutOfMemoryError*
- Access to this memory is relatively slower than stack memory
- This memory, in contrast to stack, isn’t automatically deallocated. It needs Garbage Collector to free up unused objects so as to keep the efficiency of the memory usage
- Unlike stack, a heap isn’t threadsafe and needs to be guarded by properly synchronizing the code

---

- Objects and corresponding instance variables will be stored in the heap area.

- Every array in java is object only hence arrays also will be stored in the heap area.

- Heap area can be access by multiple threads and hence the data stored in the heap area is not thread safe.

```
Set Maximum and Minimum heap size
-Xmx
     To set maximum heap size , i.e., maxMemory
    java -Xmx512m HeapSpaceDemo
     Here mx = maximum size
              512m = 512 MB
              HeapSpaceDemo = Java class name
-Xms
     To set minimum heap size , i.e., total memory 
        java -Xms65m HeapSpaceDemo   
      Here ms = minimum size
              65m = 65 MB
              HeapSpaceDemo = Java class name
or, you can set a minimum maximum heap size at a time
java -Xms256m -Xmx1024m HeapSpaceDemo
```

#### 3. Stack Memory

> **Stack Memory in Java is used for static memory allocation and the execution of a thread.** It contains primitive values that are specific to a method and references to objects that are in a heap, referred from the method.

```
Access to this memory is in Last-In-First-Out (LIFO) order. Whenever a new method is called, a new block on top of the stack is created which contains values specific to that method, like primitive variables and references to objects.

When the method finishes execution, it’s corresponding stack frame is flushed, the flow goes back to the calling method and space becomes available for the next method.
```

- It grows and shrinks as new methods are called and returned respectively

- Variables inside stack exist only as long as the method that created them is running

- It’s automatically allocated and deallocated when method finishes execution

- If this memory is full, Java throws *java.lang.StackOverFlowError*

- Access to this memory is fast when compared to heap memory

- This memory is threadsafe as each thread operates in its own stack

---

- Local Variable Array
  
  - It contains all parameters and local variables of the method.
  
  - the occupied slot 

- Operand Stack
  
  - JVM uses operand stack as work space.
  
  - last-in first-out (LIFO) 
  
  - how a Java virtual machine would add two local variables that contain ints and store the int result in a third local variable:

- Frame Data

**Stack Memory vs Heap Space**

| Parameter               | Stack Memory                                                                                             | Heap Space                                                                                                                                           |
| ----------------------- | -------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| Application             | Stack is used in parts, one at a time during execution of a thread                                       | The entire application uses Heap space during runtime                                                                                                |
| Size                    | Stack has size limits depending upon OS and is usually smaller then Heap                                 | There is no size limit on Heap                                                                                                                       |
| Storage                 | Stores only primitive variables and references to objects that are created in Heap Space                 | All the newly created objects are stored here                                                                                                        |
| Order                   | It is accessed using Last-in First-out (LIFO) memory allocation system                                   | This memory is accessed via complex memory management techniques that include Young Generation, Old or Tenured Generation, and Permanent Generation. |
| Life                    | Stack memory only exists as long as the current method is running                                        | Heap space exists as long as the application runs                                                                                                    |
| Efficiency              | Comparatively much faster to allocate when compared to heap                                              | Slower to allocate when compared to stack                                                                                                            |
| Allocation/Deallocation | This Memory is automatically allocated and deallocated when a method is called and returned respectively | Heap space is allocated when new objects are created and deallocated by Gargabe Collector when they are no longer referenced                         |

#### 4. PC Registers(Program Counter Registers)

> For every thread a separate PC register will be created at the time of thread creation. PC register contains address of current executing instruction. Once instruction execution completes automatically PC register will be incremented to hold address of next instruction. An "address" can be a native pointer or an offset from the beginning of a method's byte codes.   

#### 5. Native Method Stacks

> Here also for every Thread a separate run time stack will be created. It contains all the native methods used in the application. Native method means methods written in a language other than the Java programming language. In other words, it is a stack used to execute C/C++ codes invoked through JNI (Java Native Interface). According to the language, a C stack or C++ stack is created.

### Execution Engine

#### 1. Interpreter

> It is responsible to read byte code and interpret into machine code (native code) and execute that machine code line by line. 

#### 2. JIT Compiler

> The JIT compiler has been introduced to compensate for the disadvantages of the interpreter. The main purpose of JIT compiler is to improve the performance. Internally JIT compiler maintains a separate count for every method. Whenever JVM across any method call, first that method will be interpreted normally by the interpreter and JIT compiler increments the corresponding count variable. 

- **Profiler** which is the part of JIT compiler is responsible to identify Hotspot(Repeated Used Methods).

### Java Native Interface(JNI)

> JNI is acts as a bridge (Mediator) for java method calls and corresponding native libraries. 

### 内存大小设置

- 在命令行下用  java -Xmx1200m -XX:Max Perm Size=60m -version 命令来进行测试，然后逐渐的增大XXXX的值，如果执行正常就表示指定的内存大小可用，否则会打印错误信息。
  最后得到的虚拟机实际分配到的 
  总内存大小=堆内存+非堆内存
  1200m：为堆内存大小，如果不指定后者参数则有最大数限制，网上很多文章认为这就是JVM内存， -Xmx为设置最大堆内存
  60m： 为非堆内存大小， -XX: Max PermSize实为 永久域内存，在堆内存之外，属于非堆内存部分，jdk1.5我测了好像默认为62m，即得到非堆部分默认内存）



# 进程内存

## 查看进程对象大小

- **jmap -histo 进程id**  

  ```shell
  jmap -histo 123456 | head -n15
  ```

## 查看内存分布及回收情况

- **jstat -gc 进程id 毫秒**

  ```shell
  jstat -gc 1692 5000
  ```

  S0C: Young Generation第一个survivor space的内存大小 (kB).
  S1C: Young Generation第二个survivor space的内存大小 (kB).
  S0U: Young Generation第一个Survivor space当前已使用的内存大小 (kB).
  S1U: Young Generation第二个Survivor space当前已经使用的内存大小 (kB).
  EC: Young Generation中eden space的内存大小 (kB).
  EU: Young Generation中Eden space当前已使用的内存大小 (kB).
  OC: Old Generation的内存大小 (kB).
  OU: Old Generation当前已使用的内存大小 (kB).
  MC: Permanent Generation的内存大小 (kB)
  MU: Permanent Generation当前已使用的内存大小 (kB).
  YGC: 从启动到采样时Young Generation GC的次数
  YGCT: 从启动到采样时Young Generation GC所用的时间 (s).
  FGC: 从启动到采样时Old Generation GC的次数.
  FGCT: 从启动到采样时Old Generation GC所用的时间 (s).
  GCT: 从启动到采样时GC所用的总时间 (s).

## 查看堆栈占用

- **jmap -heap 进程id**  

  ```
  S0： 新生代中Survivor space 0区已使用空间的百分比
  S1： 新生代中Survivor space 1区已使用空间的百分比
  E ：新生代已使用空间的百分比 Eden space
  O： 老年代已使用空间的百分比（P:  永久带已使用空间的百分比）
  
  M： 元空间使用百分比
  CCS： 压缩类空间利用率为百分比
  YGC： YGC次数
  YGCT： 年轻一代垃圾收集时间
  FGC： FGC次数.
  FGCT： 完全垃圾收集时间
  GCT： 垃圾回收总时间
  ```

  
---
title: code thought
date: 2024-07-25 15:12:13
tags: thought
categories: code
---

## TDD

TDD, or Test-Driven Development, is a software development process that involves writing automated tests before writing the actual code. In other words, you write the test first, and then you implement the code to make the test pass.

Here's how it typically works:

1. **Write a test**: You write an automated test that covers a specific piece of functionality or behavior in your system.

2. **Run the test and see it fail**: Since you haven't implemented the code yet, the test will naturally fail.

3. **Write the code**: You then implement the code to make the test pass. This is where you write the actual logic, algorithms, or whatever is needed to satisfy the requirements of the test.

4. **Run the test and see it pass**: Now that you've written the code, run the test again, and if everything is correct, the test should pass!

5. **Refactor the code (if needed)**: If there are any issues with the code or if you can improve the design, you refactor the code to make it more maintainable, efficient, or easier to understand.



The key benefits of TDD include:

1. **Improved code quality**: Writing tests before writing code ensures that your code is robust and meets the requirements.

2. **Reduced bugs**: By testing each piece of functionality thoroughly, you can catch errors early on, reducing the overall number of bugs in your system.

3. **Faster development**: TDD helps you focus on implementing only what's necessary to pass the test, making your development process more efficient.

4. **Better design**: The process of writing tests and then implementing code encourages good design principles, such as separation of concerns, modularity, and maintainability.



TDD is often used in conjunction with other testing methodologies, like unit testing, integration testing, or acceptance testing, to ensure that your software system is thoroughly tested and reliable.

# idea

- [Make it work, make it right, make it fast](http://wiki.c2.com/?MakeItWorkMakeItRightMakeItFast)

  ```
  Where 'work' is making the tests pass, 'right' is refactoring the code, and 'fast' is optimizing the code to make it, for example, run quickly. We can only 'make it fast' once we've made it work and made it right. We were lucky that the code we were given was already demonstrated to be working, and didn't need to be refactored. We should never try to 'make it fast' before the other two steps have been performed because[Premature optimization is the root of all evil](http://wiki.c2.com/?PrematureOptimization)
  ```

- [If it ain't broke, don't fix it](https://en.wikipedia.org/wiki/If_it_ain't_broke,_don't_fix_it) 

- [KISS principle](https://en.wikipedia.org/wiki/KISS_principle) 
- [Don't repeat yourself](https://en.wikipedia.org/wiki/Don't_repeat_yourself) 
- [Feature creep](https://en.wikipedia.org/wiki/Feature_creep) 
- [List of software development philosophies](https://en.wikipedia.org/wiki/List_of_software_development_philosophies) -
- [Minimum viable product](https://en.wikipedia.org/wiki/Minimum_viable_product)
- [MoSCoW method](https://en.wikipedia.org/wiki/MoSCoW_method) 
- [Overengineering](https://en.wikipedia.org/wiki/Overengineering) 
- [Worse is better](https://en.wikipedia.org/wiki/Worse_is_better) 
- [S.O.L.I.D.](https://en.wikipedia.org/wiki/SOLID)
- [Unix philosophy](https://en.wikipedia.org/wiki/Unix_philosophy)